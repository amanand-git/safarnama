<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SafarEasy - Image Compressor</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;500;600;700;800&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
    />
    <style>
      :root {
        --bg-1: #030712;
        --bg-2: #0f172a;
        --bg-3: #1e293b;
        --panel: rgba(15, 23, 42, 0.82);
        --panel-border: rgba(148, 163, 184, 0.2);
        --text-main: #f8fafc;
        --text-soft: #cbd5e1;
        --text-muted: #94a3b8;
        --green: #10b981;
        --green-strong: #059669;
        --blue: #3b82f6;
        --danger: #ef4444;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        min-height: 100vh;
        font-family: "Outfit", sans-serif;
        color: var(--text-main);
        background:
          radial-gradient(circle at 18% 12%, rgba(16, 185, 129, 0.14), transparent 34%),
          radial-gradient(circle at 88% 92%, rgba(59, 130, 246, 0.14), transparent 40%),
          linear-gradient(145deg, var(--bg-1), var(--bg-2) 48%, var(--bg-3));
      }

      .top-bar {
        position: sticky;
        top: 0;
        z-index: 10;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 18px;
        border-bottom: 1px solid rgba(148, 163, 184, 0.22);
        background: rgba(2, 6, 23, 0.84);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
      }

      .brand {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        color: #6ee7b7;
        font-weight: 700;
        letter-spacing: 0.2px;
      }

      .top-actions {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .nav-btn {
        text-decoration: none;
        color: #e2e8f0;
        padding: 9px 14px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.28);
        background: rgba(15, 23, 42, 0.7);
        font-size: 13px;
        font-weight: 600;
      }

      .page {
        width: min(1200px, calc(100% - 28px));
        margin: 24px auto 34px;
      }

      .hero {
        border: 1px solid var(--panel-border);
        background: linear-gradient(135deg, rgba(15, 23, 42, 0.9), rgba(30, 41, 59, 0.8));
        border-radius: 20px;
        padding: 22px;
        margin-bottom: 18px;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        border-radius: 999px;
        padding: 7px 12px;
        border: 1px solid rgba(110, 231, 183, 0.36);
        background: rgba(16, 185, 129, 0.16);
        color: #6ee7b7;
        font-size: 13px;
        font-weight: 700;
        margin-bottom: 12px;
      }

      .hero h1 {
        font-size: 32px;
        margin-bottom: 8px;
      }

      .hero p {
        color: var(--text-soft);
        line-height: 1.6;
        font-size: 15px;
      }

      .tool-layout {
        display: grid;
        grid-template-columns: 1.08fr 0.92fr;
        gap: 16px;
      }

      .panel {
        border: 1px solid var(--panel-border);
        background: var(--panel);
        border-radius: 20px;
        padding: 18px;
      }

      .panel h2 {
        font-size: 18px;
        margin-bottom: 14px;
      }

      .uploader {
        border: 1px dashed rgba(148, 163, 184, 0.35);
        border-radius: 14px;
        padding: 20px;
        text-align: center;
        background: rgba(15, 23, 42, 0.58);
        margin-bottom: 14px;
      }

      .upload-icon {
        font-size: 30px;
        color: #86efac;
        margin-bottom: 10px;
      }

      .upload-note {
        font-size: 13px;
        color: var(--text-muted);
        margin-top: 8px;
      }

      .input-file {
        margin-top: 10px;
        font-family: inherit;
        color: var(--text-soft);
      }

      .meta-list {
        list-style: none;
        display: grid;
        gap: 8px;
      }

      .meta-list li {
        display: flex;
        justify-content: space-between;
        gap: 10px;
        border: 1px solid rgba(148, 163, 184, 0.16);
        border-radius: 12px;
        padding: 9px 12px;
        font-size: 14px;
        color: var(--text-soft);
      }

      .meta-list strong {
        color: #f8fafc;
        font-weight: 600;
      }

      .control-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        margin-bottom: 12px;
      }

      .form-field {
        display: grid;
        gap: 6px;
      }

      .form-field label {
        font-size: 13px;
        color: var(--text-soft);
      }

      .form-field input,
      .form-field select {
        width: 100%;
        background: rgba(15, 23, 42, 0.85);
        border: 1px solid rgba(148, 163, 184, 0.3);
        color: #fff;
        padding: 9px 10px;
        border-radius: 10px;
        font-family: inherit;
      }

      .quality-row {
        display: grid;
        grid-template-columns: 1fr 90px;
        gap: 10px;
      }

      .range-wrap {
        display: grid;
        gap: 8px;
      }

      .range-value {
        font-size: 12px;
        color: var(--text-muted);
      }

      .checkbox-row {
        display: flex;
        align-items: center;
        gap: 8px;
        color: var(--text-soft);
        margin-bottom: 14px;
      }

      .actions {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }

      .btn {
        border: none;
        border-radius: 11px;
        padding: 11px 14px;
        font-family: inherit;
        font-size: 14px;
        font-weight: 700;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        text-decoration: none;
      }

      .btn-primary {
        color: #052e16;
        background: linear-gradient(135deg, #34d399, var(--green));
      }

      .btn-secondary {
        color: #dbeafe;
        background: rgba(30, 64, 175, 0.24);
        border: 1px solid rgba(96, 165, 250, 0.36);
      }

      .btn-download-green {
        width: 100%;
        min-height: 50px;
        border-radius: 14px;
        font-size: 16px;
        letter-spacing: 0.2px;
        color: #dcfce7;
        background: linear-gradient(135deg, rgba(5, 150, 105, 0.55), rgba(16, 185, 129, 0.42));
        border: 1px solid rgba(74, 222, 128, 0.55);
        box-shadow:
          inset 0 1px 0 rgba(255, 255, 255, 0.14),
          0 8px 24px rgba(16, 185, 129, 0.22);
        transition: transform 0.2s ease, box-shadow 0.2s ease, filter 0.2s ease;
      }

      .btn-download-green:hover {
        transform: translateY(-1px);
        box-shadow:
          inset 0 1px 0 rgba(255, 255, 255, 0.18),
          0 12px 30px rgba(16, 185, 129, 0.3);
        filter: brightness(1.05);
      }

      .btn-muted {
        color: #e2e8f0;
        background: rgba(51, 65, 85, 0.9);
        border: 1px solid rgba(148, 163, 184, 0.24);
      }

      .btn[disabled],
      .btn.disabled {
        opacity: 0.45;
        pointer-events: none;
      }

      .status-box {
        margin-top: 12px;
        border-radius: 12px;
        padding: 10px 12px;
        border: 1px solid rgba(148, 163, 184, 0.22);
        background: rgba(15, 23, 42, 0.68);
        color: var(--text-soft);
        font-size: 13px;
        line-height: 1.6;
      }

      .status-box:empty {
        display: none;
      }

      .status-box.success {
        border-color: rgba(16, 185, 129, 0.44);
        color: #a7f3d0;
        background: rgba(6, 78, 59, 0.35);
      }

      .status-box.error {
        border-color: rgba(239, 68, 68, 0.45);
        color: #fecaca;
        background: rgba(127, 29, 29, 0.36);
      }

      .preview-wrap {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        margin-top: 14px;
      }

      .preview-card {
        border: 1px solid rgba(148, 163, 184, 0.22);
        border-radius: 14px;
        overflow: hidden;
        background: rgba(2, 6, 23, 0.65);
      }

      .preview-head {
        font-size: 12px;
        font-weight: 700;
        letter-spacing: 0.3px;
        color: #bfdbfe;
        padding: 8px 10px;
        border-bottom: 1px solid rgba(148, 163, 184, 0.18);
      }

      .preview-box {
        width: 100%;
        aspect-ratio: 1 / 1;
        display: grid;
        place-items: center;
        overflow: hidden;
        background: rgba(15, 23, 42, 0.84);
      }

      .preview-box img {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
        display: none;
      }

      .preview-empty {
        color: var(--text-muted);
        font-size: 13px;
        text-align: center;
        padding: 14px;
      }

      .download-wrap {
        margin-top: 12px;
      }

      .small-note {
        margin-top: 10px;
        font-size: 12px;
        color: var(--text-muted);
      }

      .mini-copyright {
        margin: 10px auto 18px;
        width: 100%;
        border: none;
        border-radius: 0;
        background: transparent;
        color: #cbd5e1;
        font-size: 13px;
        padding: 0 14px;
        text-align: center;
      }

      .loading-overlay {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        padding: 20px;
        background: rgba(2, 6, 23, 0.78);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        z-index: 9999;
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        transition: opacity 0.28s ease, visibility 0.28s ease;
      }

      .loading-overlay.active {
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
      }

      .loading-card {
        width: min(520px, 100%);
        border-radius: 20px;
        border: 1px solid rgba(148, 163, 184, 0.32);
        background: linear-gradient(145deg, rgba(15, 23, 42, 0.9), rgba(30, 41, 59, 0.88));
        box-shadow: 0 22px 56px rgba(2, 6, 23, 0.58);
        padding: 22px 20px;
        text-align: center;
      }

      .loading-title {
        font-size: 21px;
        font-weight: 800;
        margin-bottom: 8px;
      }

      .loading-subtitle {
        font-size: 14px;
        color: var(--text-soft);
        margin-bottom: 14px;
      }

      .try-ai-loader {
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 92px;
        height: 92px;
        background: rgba(139, 92, 246, 0.15);
        border: 1.5px solid rgba(167, 139, 250, 0.4);
        border-radius: 50%;
        box-shadow:
          0 8px 32px rgba(139, 92, 246, 0.25),
          0 0 0 1px rgba(255, 255, 255, 0.1) inset;
        overflow: hidden;
      }

      .try-ai-loader .ai-btn-glow {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 200%;
        height: 200%;
        background: radial-gradient(circle, rgba(167, 139, 250, 0.42) 0%, transparent 70%);
        animation: pulse-glow 3s ease-in-out infinite;
        pointer-events: none;
      }

      @keyframes pulse-glow {
        0%,
        100% {
          opacity: 0.6;
          transform: translate(-50%, -50%) scale(1);
        }
        50% {
          opacity: 1;
          transform: translate(-50%, -50%) scale(1.1);
        }
      }

      .try-ai-loader .ai-logo {
        width: 34px;
        height: 34px;
        object-fit: contain;
        position: relative;
        z-index: 2;
        animation: sparkle-rainbow-purple 3.5s ease-in-out infinite;
      }

      @keyframes sparkle-rainbow-purple {
        0%,
        100% {
          transform: scale(1) rotate(0deg);
          filter:
            drop-shadow(0 0 3px rgba(255, 255, 255, 0.8))
            drop-shadow(0 0 6px rgba(139, 92, 246, 0.6));
        }
        25% {
          transform: scale(1.3) rotate(15deg);
          filter:
            drop-shadow(0 0 8px rgba(255, 215, 0, 1))
            drop-shadow(0 0 12px rgba(255, 165, 0, 0.8));
        }
        50% {
          transform: scale(1) rotate(0deg);
          filter:
            drop-shadow(0 0 5px rgba(255, 255, 255, 0.9))
            drop-shadow(0 0 10px rgba(139, 92, 246, 0.7));
        }
        75% {
          transform: scale(1.25) rotate(-10deg);
          filter:
            drop-shadow(0 0 8px rgba(255, 223, 0, 1))
            drop-shadow(0 0 12px rgba(255, 140, 0, 0.8));
        }
      }

      @media (max-width: 980px) {
        .tool-layout {
          grid-template-columns: 1fr;
        }
      }

      @media (max-width: 680px) {
        .page {
          width: calc(100% - 18px);
          margin-top: 16px;
        }

        .mini-copyright {
          width: 100%;
          margin: 8px auto 14px;
          font-size: 12px;
        }

        .hero h1 {
          font-size: 27px;
        }

        .control-grid {
          grid-template-columns: 1fr;
        }

        .preview-wrap {
          grid-template-columns: 1fr;
        }

        .quality-row {
          grid-template-columns: 1fr;
        }

        .top-bar {
          gap: 10px;
          align-items: flex-start;
          flex-direction: column;
        }

        .loading-title {
          font-size: 18px;
        }

        .try-ai-loader {
          width: 84px;
          height: 84px;
        }

        .top-actions {
          width: 100%;
        }

        .nav-btn {
          flex: 1;
          text-align: center;
        }
      }
    </style>
  </head>
  <body>
    <header class="top-bar">
      <div class="brand">
        <i class="fa-solid fa-file-zipper"></i>
        SafarEasy Image Compressor
      </div>
      <div class="top-actions">
        <a href="safareasy-apps.html" class="nav-btn">Back to Apps</a>
        <a href="index.html" class="nav-btn">Home</a>
      </div>
    </header>

    <main class="page">
      <section class="hero">
        <div class="badge">
          <i class="fa-solid fa-bolt"></i>
          Working Tool
        </div>
        <h1>Compress Image by Quality and Pixels</h1>
        <p>
          Image upload karein, quality percentage set karein, width/height pixels choose karein,
          fir compress karke download karein.
        </p>
      </section>

      <section class="tool-layout">
        <div class="panel">
          <h2>1) Upload and Preview</h2>
          <div class="uploader">
            <div class="upload-icon"><i class="fa-regular fa-image"></i></div>
            <div>Select image from your device</div>
            <input id="imageInput" class="input-file" type="file" accept="image/*" />
            <div class="upload-note">Supported: JPG, PNG, WEBP, BMP</div>
          </div>

          <ul class="meta-list" id="originalMeta">
            <li><span>File Name</span> <strong id="metaName">-</strong></li>
            <li><span>Original Size</span> <strong id="metaSize">-</strong></li>
            <li><span>Original Dimensions</span> <strong id="metaDimensions">-</strong></li>
          </ul>

          <div class="preview-wrap">
            <div class="preview-card">
              <div class="preview-head">ORIGINAL</div>
              <div class="preview-box">
                <img id="originalPreview" alt="Original preview" />
                <div class="preview-empty" id="originalEmpty">No image selected</div>
              </div>
            </div>
            <div class="preview-card">
              <div class="preview-head">COMPRESSED</div>
              <div class="preview-box">
                <img id="compressedPreview" alt="Compressed preview" />
                <div class="preview-empty" id="compressedEmpty">Output will appear here</div>
              </div>
            </div>
          </div>
        </div>

        <div class="panel">
          <h2>2) Compression Controls</h2>

          <div class="form-field" style="margin-bottom: 12px;">
            <label for="qualityRange">Compression Quality (%)</label>
            <div class="quality-row">
              <div class="range-wrap">
                <input id="qualityRange" type="range" min="5" max="100" value="75" />
                <div class="range-value">Lower value = smaller file size</div>
              </div>
              <input id="qualityInput" type="number" min="5" max="100" value="75" />
            </div>
          </div>

          <div class="control-grid">
            <div class="form-field">
              <label for="widthInput">Width (px)</label>
              <input id="widthInput" type="number" min="1" placeholder="Width in pixels" />
            </div>
            <div class="form-field">
              <label for="heightInput">Height (px)</label>
              <input id="heightInput" type="number" min="1" placeholder="Height in pixels" />
            </div>
          </div>

          <label class="checkbox-row" for="lockRatio">
            <input id="lockRatio" type="checkbox" checked />
            Keep aspect ratio
          </label>

          <div class="form-field" style="margin-bottom: 14px;">
            <label for="formatSelect">Output Format</label>
            <select id="formatSelect">
              <option value="auto">Auto (based on original)</option>
              <option value="image/jpeg">JPEG</option>
              <option value="image/webp">WEBP</option>
              <option value="image/png">PNG</option>
            </select>
          </div>

          <div class="form-field" style="margin-bottom: 14px;">
            <label for="targetSizeInput">Target Size (KB) - optional</label>
            <input
              id="targetSizeInput"
              type="number"
              min="1"
              max="50000"
              placeholder="e.g. 120 for approx 120 KB output"
            />
          </div>

          <div class="actions">
            <button id="compressBtn" class="btn btn-primary" type="button">
              <i class="fa-solid fa-compress"></i>
              Compress Image
            </button>
            <button id="resetDimensionsBtn" class="btn btn-muted" type="button">
              <i class="fa-solid fa-arrows-rotate"></i>
              Reset Dimensions
            </button>
          </div>

          <div class="download-wrap">
            <a
              id="downloadBtn"
              class="btn btn-download-green disabled"
              href="#"
              download
              aria-disabled="true"
            >
              <i class="fa-solid fa-download"></i>
              Download Compressed Image
            </a>
          </div>

          <ul class="meta-list" id="resultMeta" style="margin-top: 12px;">
            <li><span>Compressed Size</span> <strong id="resultSize">-</strong></li>
            <li><span>New Dimensions</span> <strong id="resultDimensions">-</strong></li>
            <li><span>Space Saved</span> <strong id="resultSaved">-</strong></li>
            <li><span>Target Size</span> <strong id="resultTarget">-</strong></li>
          </ul>

          <div id="statusBox" class="status-box"></div>
          <div class="small-note">
            Tip: JPEG/WEBP format usually gives better compression than PNG.
          </div>
        </div>
      </section>
    </main>

    <footer class="mini-copyright">&copy; 2026 Safarnama. All Rights Reserved.</footer>

    <div id="loadingOverlay" class="loading-overlay" aria-hidden="true" aria-live="polite">
      <div class="loading-card">
        <div class="loading-title">Compressing Your Image</div>
        <div class="loading-subtitle">Safarnama AI optimization is running...</div>
        <div class="try-ai-loader" role="status">
          <div class="ai-btn-glow"></div>
          <img src="images/ailogo.png" class="ai-logo" alt="AI" />
        </div>
      </div>
    </div>

    <script>
      (() => {
        const imageInput = document.getElementById("imageInput");
        const qualityRange = document.getElementById("qualityRange");
        const qualityInput = document.getElementById("qualityInput");
        const widthInput = document.getElementById("widthInput");
        const heightInput = document.getElementById("heightInput");
        const lockRatio = document.getElementById("lockRatio");
        const formatSelect = document.getElementById("formatSelect");
        const targetSizeInput = document.getElementById("targetSizeInput");
        const compressBtn = document.getElementById("compressBtn");
        const resetDimensionsBtn = document.getElementById("resetDimensionsBtn");
        const downloadBtn = document.getElementById("downloadBtn");
        const loadingOverlay = document.getElementById("loadingOverlay");
        const statusBox = document.getElementById("statusBox");
        const originalPreview = document.getElementById("originalPreview");
        const compressedPreview = document.getElementById("compressedPreview");
        const originalEmpty = document.getElementById("originalEmpty");
        const compressedEmpty = document.getElementById("compressedEmpty");
        const metaName = document.getElementById("metaName");
        const metaSize = document.getElementById("metaSize");
        const metaDimensions = document.getElementById("metaDimensions");
        const resultSize = document.getElementById("resultSize");
        const resultDimensions = document.getElementById("resultDimensions");
        const resultSaved = document.getElementById("resultSaved");
        const resultTarget = document.getElementById("resultTarget");

        const state = {
          file: null,
          image: null,
          originalUrl: "",
          outputUrl: "",
          outputBlob: null,
          originalWidth: 0,
          originalHeight: 0
        };

        let isSyncingDimensions = false;

        function wait(ms) {
          return new Promise((resolve) => setTimeout(resolve, ms));
        }

        function setLoading(active) {
          if (!loadingOverlay) return;
          if (active) {
            loadingOverlay.classList.add("active");
            loadingOverlay.setAttribute("aria-hidden", "false");
          } else {
            loadingOverlay.classList.remove("active");
            loadingOverlay.setAttribute("aria-hidden", "true");
          }
        }

        function setStatus(message, type) {
          statusBox.textContent = message;
          statusBox.classList.remove("success", "error");
          if (type === "success") {
            statusBox.classList.add("success");
          } else if (type === "error") {
            statusBox.classList.add("error");
          }
        }

        function formatBytes(bytes) {
          if (!Number.isFinite(bytes) || bytes < 0) return "-";
          if (bytes < 1024) return bytes + " B";
          const units = ["KB", "MB", "GB"];
          let value = bytes / 1024;
          let unitIndex = 0;
          while (value >= 1024 && unitIndex < units.length - 1) {
            value = value / 1024;
            unitIndex += 1;
          }
          return value.toFixed(2) + " " + units[unitIndex];
        }

        function clampNumber(value, min, max, fallback) {
          const number = Number(value);
          if (!Number.isFinite(number)) return fallback;
          return Math.min(max, Math.max(min, Math.round(number)));
        }

        function clearOutput() {
          if (state.outputUrl) {
            URL.revokeObjectURL(state.outputUrl);
            state.outputUrl = "";
          }
          state.outputBlob = null;
          compressedPreview.removeAttribute("src");
          compressedPreview.style.display = "none";
          compressedEmpty.style.display = "block";
          downloadBtn.classList.add("disabled");
          downloadBtn.setAttribute("aria-disabled", "true");
          downloadBtn.setAttribute("href", "#");
          resultSize.textContent = "-";
          resultDimensions.textContent = "-";
          resultSaved.textContent = "-";
          resultTarget.textContent = "-";
        }

        function setOriginalMeta(file, width, height) {
          metaName.textContent = file ? file.name : "-";
          metaSize.textContent = file ? formatBytes(file.size) : "-";
          metaDimensions.textContent = width && height ? width + " x " + height + " px" : "-";
        }

        function resetDimensions() {
          if (!state.originalWidth || !state.originalHeight) return;
          widthInput.value = String(state.originalWidth);
          heightInput.value = String(state.originalHeight);
        }

        function getOutputMimeType() {
          if (formatSelect.value !== "auto") return formatSelect.value;
          const sourceType = state.file && state.file.type ? state.file.type : "";
          if (
            sourceType === "image/jpeg" ||
            sourceType === "image/png" ||
            sourceType === "image/webp"
          ) {
            return sourceType;
          }
          return "image/jpeg";
        }

        function extensionFromMime(mimeType) {
          if (mimeType === "image/jpeg") return "jpg";
          if (mimeType === "image/webp") return "webp";
          if (mimeType === "image/png") return "png";
          return "jpg";
        }

        function outputFileName(originalName, mimeType) {
          const baseName = String(originalName || "image")
            .replace(/\.[^.]+$/, "")
            .replace(/[^a-zA-Z0-9-_]/g, "-");
          return baseName + "-compressed." + extensionFromMime(mimeType);
        }

        function updateCompressedPreview(url) {
          compressedPreview.src = url;
          compressedPreview.style.display = "block";
          compressedEmpty.style.display = "none";
        }

        function getTargetBytes() {
          const raw = Number(targetSizeInput.value);
          if (!Number.isFinite(raw) || raw <= 0) return null;
          const normalizedKb = Math.min(50000, Math.max(1, Math.round(raw)));
          targetSizeInput.value = String(normalizedKb);
          return normalizedKb * 1024;
        }

        function createBlobFromCanvas(canvas, mimeType, quality) {
          return new Promise((resolve, reject) => {
            canvas.toBlob(
              (generatedBlob) => {
                if (!generatedBlob) {
                  reject(new Error("Compression failed."));
                  return;
                }
                resolve(generatedBlob);
              },
              mimeType,
              quality
            );
          });
        }

        function drawImageToCanvas(width, height, mimeType) {
          const canvas = document.createElement("canvas");
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext("2d");

          if (!ctx) {
            throw new Error("Canvas context not available.");
          }

          if (mimeType === "image/jpeg") {
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, width, height);
          }

          ctx.drawImage(state.image, 0, 0, width, height);
          return canvas;
        }

        async function createBlobWithSettings(width, height, mimeType, quality) {
          const canvas = drawImageToCanvas(width, height, mimeType);
          return createBlobFromCanvas(canvas, mimeType, quality);
        }

        async function findBestQualityAtDimensions(width, height, mimeType, maxQuality, targetBytes) {
          if (mimeType === "image/png") {
            const pngBlob = await createBlobWithSettings(width, height, mimeType, maxQuality);
            return {
              blob: pngBlob,
              usedQuality: maxQuality,
              width,
              height
            };
          }

          const highQuality = Math.min(1, Math.max(0.05, maxQuality));
          const lowQuality = 0.01;

          const highBlob = await createBlobWithSettings(width, height, mimeType, highQuality);
          if (highBlob.size <= targetBytes) {
            return {
              blob: highBlob,
              usedQuality: highQuality,
              width,
              height
            };
          }

          const lowBlob = await createBlobWithSettings(width, height, mimeType, lowQuality);
          if (lowBlob.size > targetBytes) {
            return {
              blob: lowBlob,
              usedQuality: lowQuality,
              width,
              height
            };
          }

          let low = lowQuality;
          let high = highQuality;
          let bestBlob = lowBlob;
          let bestQuality = lowQuality;

          for (let i = 0; i < 12; i += 1) {
            const mid = (low + high) / 2;
            const midBlob = await createBlobWithSettings(width, height, mimeType, mid);

            if (midBlob.size <= targetBytes) {
              bestBlob = midBlob;
              bestQuality = mid;
              low = mid;
            } else {
              high = mid;
            }
          }

          return {
            blob: bestBlob,
            usedQuality: bestQuality,
            width,
            height
          };
        }

        async function compressToExactTarget(startWidth, startHeight, mimeType, maxQuality, targetBytes) {
          let width = startWidth;
          let height = startHeight;
          let bestUnderTarget = null;
          let lastAttempt = null;

          for (let attempt = 0; attempt < 14; attempt += 1) {
            const current = await findBestQualityAtDimensions(
              width,
              height,
              mimeType,
              maxQuality,
              targetBytes
            );

            lastAttempt = current;

            if (current.blob.size <= targetBytes) {
              bestUnderTarget = current;
              break;
            }

            if (width === 1 && height === 1) {
              break;
            }

            const ratio = Math.sqrt(targetBytes / current.blob.size);
            const factor = Math.max(0.5, Math.min(0.92, ratio * 0.95));
            const nextWidth = Math.max(1, Math.floor(width * factor));
            const nextHeight = Math.max(1, Math.floor(height * factor));

            width = nextWidth === width && width > 1 ? width - 1 : nextWidth;
            height = nextHeight === height && height > 1 ? height - 1 : nextHeight;
          }

          if (!bestUnderTarget) {
            return {
              blob: lastAttempt ? lastAttempt.blob : null,
              usedQuality: lastAttempt ? lastAttempt.usedQuality : maxQuality,
              width: lastAttempt ? lastAttempt.width : startWidth,
              height: lastAttempt ? lastAttempt.height : startHeight,
              exact: false,
              targetHit: false,
              reachable: false
            };
          }

          let exactBlob = bestUnderTarget.blob;
          let padded = false;

          if (exactBlob.size < targetBytes) {
            const paddingBytes = targetBytes - exactBlob.size;
            exactBlob = new Blob([exactBlob, new Uint8Array(paddingBytes)], { type: mimeType });
            padded = true;
          }

          return {
            blob: exactBlob,
            usedQuality: bestUnderTarget.usedQuality,
            width: bestUnderTarget.width,
            height: bestUnderTarget.height,
            exact: exactBlob.size === targetBytes,
            targetHit: true,
            reachable: true,
            padded
          };
        }

        function handleFile(file) {
          clearOutput();

          if (!file) return;
          if (!file.type || !file.type.startsWith("image/")) {
            setStatus("Please choose a valid image file.", "error");
            return;
          }

          if (state.originalUrl) {
            URL.revokeObjectURL(state.originalUrl);
            state.originalUrl = "";
          }

          state.file = file;
          state.originalUrl = URL.createObjectURL(file);

          const image = new Image();
          image.onload = () => {
            state.image = image;
            state.originalWidth = image.naturalWidth;
            state.originalHeight = image.naturalHeight;

            originalPreview.src = state.originalUrl;
            originalPreview.style.display = "block";
            originalEmpty.style.display = "none";

            setOriginalMeta(file, state.originalWidth, state.originalHeight);
            resetDimensions();
            setStatus(
              "Image loaded. Set quality and pixel dimensions, then click Compress Image.",
              "success"
            );
          };

          image.onerror = () => {
            setStatus("Image could not be loaded. Try another file.", "error");
          };

          image.src = state.originalUrl;
        }

        function syncQualityFromRange() {
          qualityInput.value = qualityRange.value;
        }

        function syncQualityFromInput() {
          const value = clampNumber(qualityInput.value, 5, 100, 75);
          qualityInput.value = String(value);
          qualityRange.value = String(value);
        }

        function syncHeightFromWidth() {
          if (!lockRatio.checked || !state.originalWidth || !state.originalHeight) return;
          if (isSyncingDimensions) return;
          isSyncingDimensions = true;
          const width = clampNumber(widthInput.value, 1, 20000, state.originalWidth);
          const height = Math.max(1, Math.round((width * state.originalHeight) / state.originalWidth));
          widthInput.value = String(width);
          heightInput.value = String(height);
          isSyncingDimensions = false;
        }

        function syncWidthFromHeight() {
          if (!lockRatio.checked || !state.originalWidth || !state.originalHeight) return;
          if (isSyncingDimensions) return;
          isSyncingDimensions = true;
          const height = clampNumber(heightInput.value, 1, 20000, state.originalHeight);
          const width = Math.max(1, Math.round((height * state.originalWidth) / state.originalHeight));
          heightInput.value = String(height);
          widthInput.value = String(width);
          isSyncingDimensions = false;
        }

        async function compressImage() {
          if (!state.file || !state.image) {
            setStatus("Please select an image first.", "error");
            return;
          }

          const width = clampNumber(widthInput.value, 1, 20000, state.originalWidth);
          const height = clampNumber(heightInput.value, 1, 20000, state.originalHeight);
          const quality = clampNumber(qualityRange.value, 5, 100, 75) / 100;
          const mimeType = getOutputMimeType();
          const targetBytes = getTargetBytes();

          widthInput.value = String(width);
          heightInput.value = String(height);

          setStatus("Compressing image...", "");
          compressBtn.disabled = true;
          const startTime = Date.now();
          const minLoadingMs = 5000;
          setLoading(true);

          try {
            let output = null;

            if (targetBytes) {
              output = await compressToExactTarget(width, height, mimeType, quality, targetBytes);
            } else {
              const defaultBlob = await createBlobWithSettings(width, height, mimeType, quality);
              output = {
                blob: defaultBlob,
                usedQuality: quality,
                width,
                height,
                exact: false,
                targetHit: false,
                reachable: true,
                padded: false
              };
            }

            if (!output || !output.blob) {
              throw new Error("Compression failed.");
            }

            const blob = output.blob;
            const outputWidth = output.width || width;
            const outputHeight = output.height || height;

            clearOutput();
            state.outputBlob = blob;
            state.outputUrl = URL.createObjectURL(blob);

            updateCompressedPreview(state.outputUrl);
            downloadBtn.href = state.outputUrl;
            downloadBtn.download = outputFileName(state.file.name, mimeType);
            downloadBtn.classList.remove("disabled");
            downloadBtn.setAttribute("aria-disabled", "false");

            const savedBytes = state.file.size - blob.size;
            const savedPercent =
              state.file.size > 0 ? ((savedBytes / state.file.size) * 100).toFixed(2) : "0.00";

            const usedQualityPercent = Math.round(output.usedQuality * 100);
            qualityRange.value = String(usedQualityPercent);
            qualityInput.value = String(usedQualityPercent);
            widthInput.value = String(outputWidth);
            heightInput.value = String(outputHeight);

            resultSize.textContent = formatBytes(blob.size);
            resultDimensions.textContent = outputWidth + " x " + outputHeight + " px";
            resultSaved.textContent =
              savedBytes >= 0
                ? formatBytes(savedBytes) + " (" + savedPercent + "%)"
                : "Increased by " + formatBytes(Math.abs(savedBytes));
            resultTarget.textContent = targetBytes
              ? formatBytes(targetBytes) + (output.exact ? " (exact)" : output.targetHit ? " (near)" : " (best possible)")
              : "-";

            const elapsed = Date.now() - startTime;
            if (elapsed < minLoadingMs) {
              await wait(minLoadingMs - elapsed);
            }

            if (targetBytes && output.exact) {
              setStatus(
                "Compression complete. Output is exactly the target KB size. Click download.",
                "success"
              );
            } else if (targetBytes && !output.reachable) {
              setStatus(
                "Target size is too small for this image settings. Best possible output generated.",
                "success"
              );
            } else if (targetBytes) {
              setStatus("Compression complete near requested target size. Click download.", "success");
            } else {
              setStatus("Compression complete. Click download to save your image.", "success");
            }
          } catch (error) {
            const elapsed = Date.now() - startTime;
            if (elapsed < minLoadingMs) {
              await wait(minLoadingMs - elapsed);
            }
            setStatus("Compression failed. Try lower dimensions or another format.", "error");
          } finally {
            compressBtn.disabled = false;
            setLoading(false);
          }
        }

        imageInput.addEventListener("change", (event) => {
          const file = event.target.files && event.target.files[0] ? event.target.files[0] : null;
          handleFile(file);
        });

        qualityRange.addEventListener("input", syncQualityFromRange);
        qualityInput.addEventListener("input", syncQualityFromInput);
        widthInput.addEventListener("input", syncHeightFromWidth);
        heightInput.addEventListener("input", syncWidthFromHeight);

        resetDimensionsBtn.addEventListener("click", () => {
          if (!state.file) {
            setStatus("Please upload an image first.", "error");
            return;
          }
          resetDimensions();
          setStatus("Dimensions reset to original image size.", "success");
        });

        compressBtn.addEventListener("click", compressImage);

        window.addEventListener("beforeunload", () => {
          if (state.originalUrl) URL.revokeObjectURL(state.originalUrl);
          if (state.outputUrl) URL.revokeObjectURL(state.outputUrl);
        });
      })();
    </script>
  <script src="auth-ui.js?v=20260206e"></script>
</body>
</html>




